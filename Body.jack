class Body {

  field CircularQueue cells;
  field int cellSize;

  constructor Body new(
      int argNumCells,
      int argMaxNumCells,
      int argCellSize,
      Direction direction) {
    let cells = CircularQueue.new(argMaxNumCells);
    let cellSize = argCellSize;
    do initCells(argNumCells, direction);
    return this;
  }

  method void initCells(int numCells, Direction direction) {
    do cells.enqueue(Rectangle.new(Point.new(0, 0), cellSize));
    while (numCells > 1) {
      do extendTip(direction);
      let numCells = numCells - 1;
    } 
    return;
  }

  method void dispose() {
    do cells.dispose();
    return;
  }

  method boolean isEmpty() {
    return cells.front() = null;
  }

  method Cell firstCell() {
    return cells.back(); 
  }

  method Cell nextCell(Cell cell) {
    return cells.nextCell(cell);
  }

  method void shiftTo(int x, int y) {
    return;
  }

  method boolean extendTip(Direction direction) {
    var Rectangle newTip;
    var Rectangle tip;
    var Point topLeft;

    let tip = tip();
    let topLeft = tip.topLeft();
    let topLeft = Point.add(topLeft, direction.vector(cellSize));

    let newTip = Rectangle.new(topLeft, cellSize);
    let newTip = View.map(newTip);
    //do newTip.printString();
    //do Output.println();
    if (cells.intersect(newTip)) {
      return false;
    }
    do cells.enqueue(newTip);
    return true;
  }

  method Rectangle tip() {
    var Cell cell;
    let cell = cells.front();
    return cell.rect();
  }

  method void trimEnd() {
    do cells.dequeue();
    return;
  }

  method Rectangle end() {
    var Cell cell;
    let cell = cells.back();
    return cell.rect();
  }

  method boolean isDead() {
    return cells.isEmpty();
  }
}
